// Andrey Vasilyev
// CSIS 352
// dynamichashtable.h
// 04/19/2009
// Assignment 6

#ifndef _DYNAMICHASHTABLE_
#define _DYNAMICHASHTABLE_

#include <cassert>
#include <string>
#include <iostream>
#include <list> // list from Standard Template Library
using namespace std;

//*********** The description of the class DynamicHashTable ******************
// The file dynamichashtable.h contains declaration and implementation of the 
// template class DynamicHashTable that can store elements of any data type. 
// Hash table is designed as a dynamic array of lists. The main idea of that 
// type of the table is that elements could be inserted in the same position of 
// the array if they have the same index but different key value. As a 
// result of this the number of collisions increased and the elements are saved 
// as a linked chain in the array of lists. 
//*****************************************************************************

template<class Type>
class DynamicHashTable
{
public:
	// default constructor
    //    preconditions - no validity checking is performed
    //       - table size must be more than zero
    //    postconditions
    //       - the list of table size is allocated 
    //       - collisions are set to zero    
	// if no arguments are given, the size of the list 
	//			becomes equal to 100 elements by default
    //    method input - table size as an integer number
    //    method output - none
	DynamicHashTable(int tableSize = 100);
	
	//destructor
    //Remove all elements from the array.
    //Postcondition: The array (list) holding the elements is deleted.
	~DynamicHashTable();
	
	// method: InsertItem - adds an element to hash table
    //    preconditions - an element is a valid data type
    //    postconditions - an element is added to the hash table as linked item in
	//		the same index position of the array or as a new element of the array 
	//			 - if the element is added in the hash table successfully
	//		true is returned if an element is added successfully 
	//    method input - none
    //    method output - logical value
	bool addEntry(const Type& newItem);

    // method: inTable - checks if element passed as a parameter exists in the hash table  
    //    preconditions - element is a valid data type
    //    postconditions - true value is returned if the element exists in the hash table
    //    method input - none
    //    method output - logical value
	bool inTable(const Type& newItem);
	
	// method: retrieveEntry() - returns the element of the hash table by 
	//		array index and value of the key   
    //    preconditions - element is a valid data type
    //    postconditions - element is returned if it exists in the hash table
    //    method input - none
    //    method output - element of the hash table
	Type& retrieveEntry(const Type& newItem); 	

	// method: getCollisions() - returns the number of collisions that
	//    occured if elements with the same index are inserted in the 
	//    same position of the list 
	//    preconditions - none
    //    postconditions - none
    //    method input - none
    //    method output - the number of collisions as an integer number
	int getCollisions();
	
private:
    int tableSize; 
    int collisions;
    list<Type> *listArray;  // declaration the array of lists from STL
};

// constructor
template<class Type>
DynamicHashTable<Type>::DynamicHashTable(int tableSize) 
{
	listArray = new list<Type>[tableSize];
	collisions=0;
}

// desctructor
template<class Type>
DynamicHashTable<Type>::~DynamicHashTable() //destructor
{
   delete [] listArray;
}

// The method addEntry() – adds the element in the position of 
// the array that was generated by hash function. Before the 
// element is inserted in the hash table it is compared with all 
// elements which have the same index in the list. If there is element 
// with the same index and key value the element to be inserted is discarded. 
template<class Type>
bool DynamicHashTable<Type>::addEntry(const Type& newItem)
{
	int index=newItem.hash();
	
	bool elementExist=false; 
	if (listArray[index].size()>=1)
	{
		collisions++;
		for(int i=0; i<listArray[index].size(); i++)
		{
			if(listArray[index].front()==newItem)
			{
			 	elementExist=true;
				break;
			}
			else
			{
				// standard methods of the class STL list are used  
				listArray[index].push_back(listArray[index].front());
				listArray[index].pop_front();
			}
		}	
		if(elementExist==true)
		{
			return false;
		}
		else
		{
			listArray[index].push_back(newItem);
			return true;
		}
	}
	else
	{
		listArray[index].push_back(newItem);
		return true;
	}
}

template<class Type>
bool DynamicHashTable<Type>::inTable(const Type& newItem)
{
	
	int index=newItem.hash();
	for(int i=0; i<listArray[index].size(); i++)
	{
		if(listArray[index].front()==newItem)
		{
		 	return true;
		}
		else
		{
			listArray[index].push_back(listArray[index].front());
			listArray[index].pop_front();
		}
	}

	return false;
}

// the method returns the element from the list with 
// the index and key value equal to the 
// element passed as a parametr
template<class Type>
Type& DynamicHashTable<Type>::retrieveEntry(const Type& newItem)
{
	int index=newItem.hash();
	for(int i=0; i<listArray[index].size(); i++)
	{
		if(listArray[index].front()==newItem)
		{
		 	return listArray[index].front();
		}
		else
		{
			listArray[index].push_back(listArray[index].front());
			listArray[index].pop_front();
		}
	}
}

template<class Type>
int DynamicHashTable<Type>::getCollisions()
{
	return collisions;
}


#endif


